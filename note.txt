연관관계 주인 = fk를 가진 오브젝트

연관관계의 주인 ? fk를 누가 가지고 있느냐
jpa 는 그냥 board 를 select를 하는것이 아님
-> board table 내의 user를 처리 불가
따라서 board select를 할때 db에서 user를 join하여 처리함
쓸모 있을 수 있으나 아닐 경우도 있음

FetchType.Eager : 무조건 들고옴
FetchType.Lazy : 나중에 들고옴


json 왜 탄생, 어떻게 사용?
@Controller <-req- json/mime
return java -rsp-> json/mime

영속성 컨텍스트
<- JPA가 가지고 있음

모든 요청은 @Controller를 통해 모임, 응답도 여기서함 (CRUD)
@Contoller 에서 user 객체를 만들어 save가 되면
영속성 컨텍스트에서 user를 1차 캐시에 쌓임 : 영속화
이를 db에 옮김 -> 테이블에 새 row로 쌓임 : flush
flush가 진행될때 1차 캐시에서 사라지지 않음 -> select시 영속성 컨텍스트에 존재한다면 db를 거치지 않고 접근함
up  date : select -> 영속화 -> "data 변경" save -> id를 비교하여 동일 객체가 영속화 되어있으면 수정 -> db와 동일하게 함
@Transactional은 영속화된 객체를 가져와서 변경감지, 변경된 것이 있다면 db에 수정 -> 더티 체킹

get 요청
 body없이 데이터를 전송 url에 담아서 전송
 -> select시 사용 그냥 씀

post,put,delete 요청 (데이터를 변경)
 데이터를 담아 보내야 함 -> body
 username, password, email. ...
 form 태그 method="post" 형식으로 지정가능하나, get, post만 가능 (key=value 형태로 전송)
 put, delete는 불가능 -> javascript 로 요청해야함

통일 : javascript로 ajax요청 + data : json 통일 - 사용
form:form 태그 -> post, put, delete, get요청 가능 - 사용안함
-> <form:form method="post"></form:form> 형태로 사용

스프링 컨트롤러의 파싱 전략
key=value의 형태로 데이터를 받으면
1. method의 매개변수로 전달
2. 오브젝트를 만드는 역할 <-setter가 없을시 불가능

오브젝트로 데이터 받기
post 방식의 key=value(x-www-form-urlencoded)
단 class내의 field명과 같아야만 넣어줌
field가 비어있다면 null을 넣어줌
field 보다 많다면 err -> setter를 못찾음
-> 사실 그렇지 않음 그냥 무시함

key=value가 아닌 데이터의 파싱 방법
@RequestBody 를 통해서 파싱
이는 json을 수신하여 jackson lib이 작동

json 데이터를 전송방법
폼태그 만들어서 전송

script는 헤더에 적지 않고 </body>와 가장 가까운 곳에 작성
-> 인터프리터 언어의 특성상 먼저 변수들 생성 후에 처리 해주는 식으로 사용
-> user.js를 호출하고 난후 jquery 관련 스크립트가 추가됨, 에러 발생하여 header로 다시 올림

에러 확인 방법
console에서 에러 확인, network에서 요구 파일들 정상적으로 로드 되는지 확인

회원가입시 ajax 사용 이유
1. 요청에 대한 응답을 html이 아닌 Data(json)를 받기 위해서
-> 사용자가 브라우저일수도 있으나, 앱일 경우 html을 이해하지 못함
-> 앱은 정확히는 자바코드를 통해 화면을 그려야하나 자바코드를 리턴 못함
-> 브라우저는 항상 요청만 함, 화면을 그려줘야 할 필요 있음
->> 앱과 브라우저의 리턴이 다름, 그래서 data를 리턴하는 서버를 만듬

2. 비동기 통신을 하기 위해서
cpu 작업이 아닌, mem io 처리같은 경우 시간이 오래걸림 -> 이를 동기적으로 처리 할 경우 사용자 경험 저하
cpu 작업을 하는 것 과 별개로 io를 처리함
io가 완료되면 interrupt 이를 callback이라 함 -> io 관련 처리
-> 비동기적 실행