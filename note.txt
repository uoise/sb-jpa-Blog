연관관계 주인 = fk를 가진 오브젝트

연관관계의 주인 ? fk를 누가 가지고 있느냐
jpa 는 그냥 board 를 select를 하는것이 아님
-> board table 내의 user를 처리 불가
따라서 board select를 할때 db에서 user를 join하여 처리함
쓸모 있을 수 있으나 아닐 경우도 있음

FetchType.Eager : 무조건 들고옴
FetchType.Lazy : 나중에 들고옴


json 왜 탄생, 어떻게 사용?
@Controller <-req- json/mime
return java -rsp-> json/mime

영속성 컨텍스트
<- JPA가 가지고 있음

모든 요청은 @Controller를 통해 모임, 응답도 여기서함 (CRUD)
@Contoller 에서 user 객체를 만들어 save가 되면
영속성 컨텍스트에서 user를 1차 캐시에 쌓임 : 영속화
이를 db에 옮김 -> 테이블에 새 row로 쌓임 : flush
flush가 진행될때 1차 캐시에서 사라지지 않음 -> select시 영속성 컨텍스트에 존재한다면 db를 거치지 않고 접근함
up  date : select -> 영속화 -> "data 변경" save -> id를 비교하여 동일 객체가 영속화 되어있으면 수정 -> db와 동일하게 함
@Transactional은 영속화된 객체를 가져와서 변경감지, 변경된 것이 있다면 db에 수정 -> 더티 체킹

get 요청
 body없이 데이터를 전송 url에 담아서 전송
 -> select시 사용 그냥 씀

post,put,delete 요청 (데이터를 변경)
 데이터를 담아 보내야 함 -> body
 username, password, email. ...
 form 태그 method="post" 형식으로 지정가능하나, get, post만 가능 (key=value 형태로 전송)
 put, delete는 불가능 -> javascript 로 요청해야함

통일 : javascript로 ajax요청 + data : json 통일 - 사용
form:form 태그 -> post, put, delete, get요청 가능 - 사용안함
-> <form:form method="post"></form:form> 형태로 사용

스프링 컨트롤러의 파싱 전략
key=value의 형태로 데이터를 받으면
1. method의 매개변수로 전달
2. 오브젝트를 만드는 역할 <-setter가 없을시 불가능

오브젝트로 데이터 받기
post 방식의 key=value(x-www-form-urlencoded)
단 class내의 field명과 같아야만 넣어줌
field가 비어있다면 null을 넣어줌
field 보다 많다면 err -> setter를 못찾음
-> 사실 그렇지 않음 그냥 무시함

key=value가 아닌 데이터의 파싱 방법
@RequestBody 를 통해서 파싱
이는 json을 수신하여 jackson lib이 작동

json 데이터를 전송방법
폼태그 만들어서 전송

script는 헤더에 적지 않고 </body>와 가장 가까운 곳에 작성
-> 인터프리터 언어의 특성상 먼저 변수들 생성 후에 처리 해주는 식으로 사용
